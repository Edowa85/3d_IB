# Database Documentation

**Project:** 3Dcard - Social Icebreaker Game
**Database:** MongoDB
**ODM:** Mongoose
**Version:** 1.0.0
**Author:** Petri
**Date:** February 2026

---

## Table of Contents

1. [Overview](#overview)
2. [Database Architecture](#database-architecture)
3. [Collections](#collections)
4. [Entity Relationships](#entity-relationships)
5. [Indexes](#indexes)
6. [Data Flow](#data-flow)
7. [CRUD Operations](#crud-operations)
8. [Security Considerations](#security-considerations)

---

## Overview

3Dcard uses **MongoDB** as its primary database for the full application version. The database stores user accounts and their personal question collections. Each user's data is isolated to ensure privacy and data security.

### Database Connection

```javascript
// Connection string (configured in .env)
MONGODB_URI=mongodb://localhost:27017/3dcard

// Database name: 3dcard
```

### Technology Stack

| Component | Technology | Purpose |
|-----------|-----------|---------|
| Database | MongoDB | NoSQL document storage |
| ODM | Mongoose | Object Data Modeling for Node.js |
| Password Hashing | bcryptjs | Secure password storage (10 salt rounds) |

---

## Database Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Application Layer"
        WebServer[Express.js Server]
        AuthMiddleware[Authentication Middleware]
        Routes[API Routes]
    end

    subgraph "Data Access Layer"
        MongooseODM[Mongoose ODM]
        UserModel[User Model]
        QuestionModel[Question Model]
    end

    subgraph "Database Layer"
        MongoDB[(MongoDB Database<br/>3dcard)]
        UsersCollection[users Collection]
        QuestionsCollection[questions Collection]
    end

    WebServer --> AuthMiddleware
    AuthMiddleware --> Routes
    Routes --> MongooseODM
    MongooseODM --> UserModel
    MongooseODM --> QuestionModel
    UserModel --> MongoDB
    QuestionModel --> MongoDB
    MongoDB --> UsersCollection
    MongoDB --> QuestionsCollection

    style MongoDB fill:#4DB33D
    style WebServer fill:#3399DB
    style MongooseODM fill:#880E4F
```

### Database Naming Convention

```mermaid
flowchart LR
    DB_NAME[Database Name<br/>3dcard] --> COLL1[Collection: users]
    DB_NAME --> COLL2[Collection: questions]

    style DB_NAME fill:#4DB33D
    style COLL1 fill:#FF6F00
    style COLL2 fill:#FF6F00
```

---

## Collections

### users Collection

Stores user account information with encrypted passwords.

```mermaid
erDiagram
    USER {
        ObjectId _id PK "Primary Key"
        string username UK "Unique, 3-30 chars"
        string password "Hashed (bcrypt)"
        date createdAt "Auto-generated"
        date updatedAt "Auto-updated"
    }
```

#### Schema Definition

```javascript
// File: full-app/models/User.js

{
  _id: ObjectId,           // Auto-generated primary key
  username: String,        // Required, unique, trimmed, 3-30 chars
  password: String,        // Required, min 6 chars, bcrypt hashed
  createdAt: Date,         // Auto-generated timestamp
  updatedAt: Date          // Auto-updated on save
}
```

#### Field Specifications

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `_id` | ObjectId | Primary Key | Auto-generated by MongoDB |
| `username` | String | Required, Unique, Trimmed, 3-30 chars | User's unique identifier for login |
| `password` | String | Required, Min 6 chars | Bcrypt hashed password (10 salt rounds) |
| `createdAt` | Date | Auto-generated | Timestamp when account was created |
| `updatedAt` | Date | Auto-generated | Timestamp of last modification |

#### Sample Document

```json
{
  "_id": "507f1f77bcf86cd799439011",
  "username": "icebreaker_joe",
  "password": "$2a$10$XWijklmnoPQRSTuvwxyZ1234567890abcdefgHIJ",
  "createdAt": "2026-02-03T10:30:00.000Z",
  "updatedAt": "2026-02-03T10:30:00.000Z"
}
```

---

### questions Collection

Stores conversation questions created by users.

```mermaid
erDiagram
    QUESTION {
        ObjectId _id PK "Primary Key"
        string text "Required, 5-500 chars"
        ObjectId createdBy FK "Ref: User._id"
        date createdAt "Auto-generated"
        date updatedAt "Auto-updated"
    }
```

#### Schema Definition

```javascript
// File: full-app/models/Question.js

{
  _id: ObjectId,           // Auto-generated primary key
  text: String,            // Required, trimmed, 5-500 chars
  createdBy: ObjectId,     // Required, references User._id
  createdAt: Date,         // Auto-generated timestamp
  updatedAt: Date          // Auto-updated on save
}
```

#### Field Specifications

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `_id` | ObjectId | Primary Key | Auto-generated by MongoDB |
| `text` | String | Required, Trimmed, 5-500 chars | The conversation question text |
| `createdBy` | ObjectId | Required, Foreign Key | Reference to User who created the question |
| `createdAt` | Date | Auto-generated | Timestamp when question was created |
| `updatedAt` | Date | Auto-generated | Timestamp of last modification |

#### Sample Document

```json
{
  "_id": "507f1f77bcf86cd799439012",
  "text": "What's something you've always wanted to try but haven't yet?",
  "createdBy": "507f1f77bcf86cd799439011",
  "createdAt": "2026-02-03T11:15:00.000Z",
  "updatedAt": "2026-02-03T11:15:00.000Z"
}
```

---

## Entity Relationships

### Entity Relationship Diagram

```mermaid
erDiagram
    USER ||--o{ QUESTION : creates
    USER {
        ObjectId _id PK
        string username UK
        string password
        date createdAt
        date updatedAt
    }
    QUESTION {
        ObjectId _id PK
        string text
        ObjectId createdBy FK
        date createdAt
        date updatedAt
    }
```

### Relationship Details

| Relationship | Type | Description |
|-------------|------|-------------|
| User → Question | One-to-Many | A user can create multiple questions |
| Question → User | Many-to-One | Each question belongs to exactly one user |

### Relationship Visualization

```mermaid
graph LR
    subgraph "User: icebreaker_joe"
        USER1[User ID: 507f1...39011]
    end

    subgraph "Questions by User"
        Q1[Question 1<br/>ID: 507f1...39012]
        Q2[Question 2<br/>ID: 507f1...39013]
        Q3[Question 3<br/>ID: 507f1...39014]
    end

    USER1 -->|"creates"| Q1
    USER1 -->|"creates"| Q2
    USER1 -->|"creates"| Q3

    style USER1 fill:#2196F3
    style Q1 fill:#FF9800
    style Q2 fill:#FF9800
    style Q3 fill:#FF9800
```

---

## Indexes

### Index Strategy

```mermaid
graph TB
    subgraph "users Collection Indexes"
        U1[username: 1<br/>UNIQUE]
    end

    subgraph "questions Collection Indexes"
        Q1[createdBy: 1]
        Q2[createdBy: 1, createdAt: -1]
    end

    style U1 fill:#4CAF50
    style Q1 fill:#4CAF50
    style Q2 fill:#4CAF50
```

### Index Definitions

#### Users Collection

| Index | Type | Purpose |
|-------|------|---------|
| `username: 1` | Unique | Fast login lookup, enforces uniqueness |

```javascript
// Automatically created by Mongoose
userSchema.index({ username: 1 }, { unique: true });
```

#### Questions Collection

| Index | Type | Purpose |
|-------|------|---------|
| `createdBy: 1` | Single | Fast lookup of user's questions |
| `createdBy: 1, createdAt: -1` | Compound | Sorted question lists (newest first) |

```javascript
questionSchema.index({ createdBy: 1 });
questionSchema.index({ createdBy: 1, createdAt: -1 });
```

### Query Performance

```mermaid
sequenceDiagram
    participant App as Application
    participant Mongo as MongoDB

    Note over App,Mongo: Query with Index
    App->>Mongo: db.questions.find({ createdBy: userId })
    Mongo->>Mongo: Use index: createdBy_1
    Mongo-->>App: Results in O(log n)

    Note over App,Mongo: Query without Index
    App->>Mongo: db.questions.find({ text: "search" })
    Mongo->>Mongo: Collection scan
    Mongo-->>App: Results in O(n)
```

---

## Data Flow

### Authentication Flow

```mermaid
sequenceDiagram
    participant User
    participant Express as Express Server
    participant Mongoose as Mongoose ODM
    participant Mongo as MongoDB

    Note over User,Mongo: User Registration (Signup)
    User->>Express: POST /signup {username, password}
    Express->>Express: Validate input (3-30 chars username)
    Express->>Mongoose: User.findOne({username})
    Mongoose->>Mongo: Query users collection
    Mongo-->>Mongoose: null (username available)
    Mongoose-->>Express: User not found

    Express->>Mongoose: new User({username, password}).save()
    Mongoose->>Mongoose: Pre-save: Hash password (bcrypt)
    Note over Mongoose: bcrypt.hash(password, 10)
    Mongoose->>Mongo: Insert user document
    Mongo-->>Mongoose: User created with _id
    Mongoose-->>Express: User saved

    Express->>Express: req.session.user = { _id, username }
    Express-->>User: Redirect to home (302)

    Note over User,Mongo: User Login
    User->>Express: POST /login {username, password}
    Express->>Mongoose: User.findOne({username})
    Mongoose->>Mongo: Query users collection
    Mongo-->>Mongoose: User document
    Mongoose-->>Express: User found

    Express->>Mongoose: user.comparePassword(password)
    Note over Mongoose: bcrypt.compare(candidate, hash)
    Mongoose-->>Express: Password match: true

    Express->>Express: req.session.user = { _id, username }
    Express-->>User: Redirect to home (302)
```

### Question CRUD Flow

```mermaid
sequenceDiagram
    participant User
    participant Express as Express Server
    participant Auth as requireLogin Middleware
    participant Mongoose as Mongoose ODM
    participant Mongo as MongoDB

    Note over User,Mongo: Create Question
    User->>Express: POST /questions {text}
    Express->>Auth: Check session
    Auth->>Auth: req.session.user exists?
    alt Not authenticated
        Auth-->>User: Redirect to /login
    else Authenticated
        Auth->>Express: next()
        Express->>Express: Validate text (5-500 chars)
        Express->>Mongoose: Question.create({text, createdBy: userId})
        Mongoose->>Mongo: Insert question document
        Mongo-->>Mongoose: Question created
        Mongoose-->>Express: Question with _id
        Express-->>User: Redirect to /questions
    end

    Note over User,Mongo: Read User's Questions
    User->>Express: GET /questions
    Express->>Auth: Check session
    Auth-->>Express: next()
    Express->>Mongoose: Question.find({createdBy: userId})
    Mongoose->>Mongo: Query with index (createdBy: 1)
    Mongo-->>Mongoose: Array of questions
    Mongoose-->>Express: Questions sorted by createdAt
    Express-->>User: Render questions.ejs

    Note over User,Mongo: Get Random Question
    User->>Express: GET /api/questions/random
    Express->>Auth: Check session
    Auth-->>Express: next()
    Express->>Mongoose: Question.aggregate([<br/>  {$match: {createdBy: userId}},<br/>  {$sample: {size: 1}}<br/>])
    Mongoose->>Mongo: Aggregation pipeline
    Mongo-->>Mongoose: One random question
    Mongoose-->>Express: Question document
    Express-->>User: JSON response

    Note over User,Mongo: Update Question
    User->>Express: PUT /questions/:id {text}
    Express->>Auth: Check session
    Auth-->>Express: next()
    Express->>Mongoose: Question.findOneAndUpdate(<br/>  {_id: id, createdBy: userId},<br/>  {text}<br/>)
    Mongoose->>Mongo: Find and update
    alt Question not found or wrong user
        Mongo-->>Mongoose: null
        Mongoose-->>Express: null
        Express-->>User: 404 Not Found
    else Found and ownership verified
        Mongo-->>Mongoose: Updated question
        Mongoose-->>Express: Updated document
        Express-->>User: Redirect to /questions
    end

    Note over User,Mongo: Delete Question
    User->>Express: DELETE /questions/:id
    Express->>Auth: Check session
    Auth-->>Express: next()
    Express->>Mongoose: Question.findOneAndDelete(<br/>  {_id: id, createdBy: userId}<br/>)
    Mongoose->>Mongo: Find and delete
    alt Question not found or wrong user
        Mongo-->>Mongoose: null
        Mongoose-->>Express: null
        Express-->>User: 404 Not Found
    else Found and ownership verified
        Mongo-->>Mongoose: Deleted question
        Mongoose-->>Express: Deleted document
        Express-->>User: Redirect to /questions
    end
```

---

## CRUD Operations

### Create Operations

```mermaid
graph TD
    A[Create Request] --> B{Entity Type}
    B -->|User| C[Create User]
    B -->|Question| D[Create Question]

    C --> E[Validate username<br/>3-30 chars]
    C --> F[Hash password<br/>bcrypt 10 rounds]
    C --> G[Insert to users]

    D --> H[Validate text<br/>5-500 chars]
    D --> I[Set createdBy = session.user._id]
    D --> J[Insert to questions]

    style C fill:#2196F3
    style D fill:#FF9800
```

#### Create User

```javascript
// Mongoose operation
const user = await User.create({
  username: 'icebreaker_joe',
  password: 'plaintext123'  // Auto-hashed by pre-save hook
});

// MongoDB query executed
db.users.insertOne({
  username: 'icebreaker_joe',
  password: '$2a$10$...',  // Hashed
  createdAt: ISODate('2026-02-03T10:30:00Z'),
  updatedAt: ISODate('2026-02-03T10:30:00Z')
})
```

#### Create Question

```javascript
// Mongoose operation
const question = await Question.create({
  text: 'What is your favorite memory?',
  createdBy: req.session.user._id
});

// MongoDB query executed
db.questions.insertOne({
  text: 'What is your favorite memory?',
  createdBy: ObjectId('507f1f77bcf86cd799439011'),
  createdAt: ISODate('2026-02-03T11:00:00Z'),
  updatedAt: ISODate('2026-02-03T11:00:00Z')
})
```

---

### Read Operations

```mermaid
graph TD
    A[Read Request] --> B{Entity Type}
    B -->|User| C[Find User by Username]
    B -->|Questions| D[Find by User ID]
    B -->|Random| E[Random Question]

    C --> F[db.users.findOne<br/>({username})]

    D --> G[db.questions.find<br/>({createdBy: userId})<br/>.sort({createdAt: -1})]

    E --> H[db.questions.aggregate<br/>([{$match}, {$sample}])]

    style C fill:#2196F3
    style D fill:#FF9800
    style E fill:#4CAF50
```

#### Find User (Login)

```javascript
// Mongoose operation
const user = await User.findOne({ username: 'icebreaker_joe' });

// MongoDB query executed
db.users.findOne({ username: 'icebreaker_joe' })

// Uses index: username_1 (UNIQUE)
```

#### Find User's Questions

```javascript
// Mongoose operation
const questions = await Question.find({ createdBy: userId })
  .sort({ createdAt: -1 });

// MongoDB query executed
db.questions.find({ createdBy: ObjectId('...') })
  .sort({ createdAt: -1 })

// Uses index: createdBy_1_createdAt_-1
```

#### Get Random Question

```javascript
// Mongoose operation
const question = await Question.aggregate([
  { $match: { createdBy: userId } },
  { $sample: { size: 1 } }
]);

// MongoDB query executed
db.questions.aggregate([
  { $match: { createdBy: ObjectId('...') } },
  { $sample: { size: 1 } }
])
```

---

### Update Operations

```mermaid
graph TD
    A[Update Request] --> B{Authorization}
    B -->|Not owner| C[404 Not Found]
    B -->|Owner| D[Execute Update]

    D --> E[Validate new data]
    E --> F[Update document]
    F --> G[Set updatedAt]

    style C fill:#F44336
    style D fill:#4CAF50
```

#### Update Question

```javascript
// Mongoose operation
const question = await Question.findOneAndUpdate(
  { _id: questionId, createdBy: userId },  // Ownership check
  { text: 'Updated question text?' },
  { new: true }
);

// MongoDB query executed
db.questions.findOneAndUpdate(
  {
    _id: ObjectId('...'),
    createdBy: ObjectId('...')
  },
  {
    $set: { text: 'Updated question text?' },
    $currentDate: { updatedAt: true }
  }
)
```

---

### Delete Operations

```mermaid
graph TD
    A[Delete Request] --> B{Authorization}
    B -->|Not owner| C[404 Not Found]
    B -->|Owner| D[Execute Delete]

    D --> E[Remove document]
    E --> F[Return deleted count]

    style C fill:#F44336
    style D fill:#4CAF50
```

#### Delete Question

```javascript
// Mongoose operation
const question = await Question.findOneAndDelete({
  _id: questionId,
  createdBy: userId  // Ownership check
});

// MongoDB query executed
db.questions.findOneAndDelete({
  _id: ObjectId('...'),
  createdBy: ObjectId('...')
})
```

---

## Security Considerations

### Password Security

```mermaid
graph TB
    subgraph "Password Lifecycle"
        A[User enters<br/>plaintext password] --> B[Bcrypt Hashing<br/>10 salt rounds]
        B --> C[Stored in MongoDB<br/>as hash only]
        C --> D[Login: Compare<br/>plaintext with hash]
        D --> E{bcrypt.compare}
        E -->|Match| F[Access granted]
        E -->|No match| G[Access denied]
    end

    style B fill:#4CAF50
    style C fill:#2196F3
    style F fill:#4CAF50
    style G fill:#F44336
```

### Security Measures

| Security Aspect | Implementation | Purpose |
|----------------|----------------|---------|
| **Password Hashing** | bcrypt, 10 salt rounds | Protects passwords if database is compromised |
| **Unique Usernames** | Unique index on username | Prevents duplicate accounts |
| **Input Validation** | Mongoose schema validation | Prevents invalid/malicious data |
| **Ownership Check** | createdBy + _id in queries | Users can only access their own data |
| **Session Management** | Express-session, HTTP-only cookies | Prevents session hijacking |
| **SQL Injection** | Not applicable (NoSQL) | MongoDB is NoSQL, less vulnerable |
| **XSS Prevention** | Input sanitization | Prevents malicious script injection |

### Data Isolation

```mermaid
graph TB
    subgraph "User A: alice"
        UA[User: alice]
        QA1[Question 1]
        QA2[Question 2]
        QA3[Question 3]
    end

    subgraph "User B: bob"
        UB[User: bob]
        QB1[Question 1]
        QB2[Question 2]
    end

    subgraph "Query Protection"
        Q[Question Query]
        QC[WHERE createdBy = session.user._id]
    end

    UA --> QA1
    UA --> QA2
    UA --> QA3
    UB --> QB1
    UB --> QB2

    Q --> QC
    QC -->|"alice's session"| QA1
    QC -->|"alice's session"| QA2
    QC -->|"bob's session"| QB1

    QC -.->|"Cannot access"| QA3
    QC -.->|"Cannot access"| QB2

    style UA fill:#E91E63
    style UB fill:#2196F3
    style QC fill:#4CAF50
```

---

## Database Schema Summary

### Complete Schema Overview

```mermaid
erDiagram
    USER ||--o{ QUESTION : owns

    USER {
        ObjectId _id PK "Auto-generated"
        string username UK "3-30 chars, indexed"
        string password "Bcrypt hashed, 10 rounds"
        date createdAt "Auto timestamp"
        date updatedAt "Auto timestamp"
    }

    QUESTION {
        ObjectId _id PK "Auto-generated"
        string text "5-500 chars, required"
        ObjectId createdBy FK "References USER._id"
        date createdAt "Auto timestamp"
        date updatedAt "Auto timestamp"
    }
```

### Collection Statistics

| Collection | Documents (typical) | Indexes | Size (typical) |
|------------|---------------------|---------|----------------|
| users | N/A | 1 (username) | Small per document (~200B) |
| questions | N/A | 2 (createdBy, compound) | Small per document (~300B) |

---

## Appendix

### Mongoose Model Files

| Model | File Path | Description |
|-------|-----------|-------------|
| User | `full-app/models/User.js` | User schema with password hashing |
| Question | `full-app/models/Question.js` | Question schema with user reference |

### Database Connection

| Environment | Connection String |
|-------------|-------------------|
| Development (Local) | `mongodb://localhost:27017/3dcard` |
| Production (Atlas) | `mongodb+srv://USER:PASS@cluster.mongodb.net/3dcard` |

### Useful MongoDB Commands

```bash
# Connect to MongoDB
mongosh

# Switch to database
use 3dcard

# List all collections
show collections

# View all users
db.users.find()

# View all questions with user info
db.questions.aggregate([
  { $lookup: { from: 'users', localField: 'createdBy', foreignField: '_id', as: 'user' } }
])

# Count documents
db.users.countDocuments()
db.questions.countDocuments()

# View indexes
db.users.getIndexes()
db.questions.getIndexes()

# Drop database
use 3dcard
db.dropDatabase()
```

---

*This database documentation is part of the 3Dcard project technical documentation. For additional information, see [technical-docs.md](./technical-docs.md).*
